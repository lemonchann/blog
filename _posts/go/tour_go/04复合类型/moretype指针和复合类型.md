> 对于一般的语言使用者来说 ，20% 的语言特性就能够满足 80% 的使用需求，剩下在使用中掌握。基于这一理论，Go 基础系列的文章不会刻意追求面面俱到，但该有知识点都会覆盖，目的是带你快跑赶上 Golang 这趟新车。

前面我们学习了 Golang 中基础数据类型，比如内置类型 `int` `string` `bool` 等，还有一些复杂一点点，但很好用的复合类型，类似 C 中的数组和 `struct`、C++ 中的 `map` ，今天我们就来学习 Go 中的复合类型。

通过本文的学习你将掌握以下知识：

- 结构体
- 指针类型
- 数组和切片
- 映射类型
- 遍历切片和映射



## 结构体

结构体是一种聚合的数据类型，与 C 中的结构体类似，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员，看例子：

```go
type Test struct {
		a int
		b int
	}
```

语法上的不同看到了吗？ 每个结构体字段之后没有分号（还记得前面文章说过 Go 会自动加分号吧）没有分号写起来还是很舒服的。



### 初始化

可以在定义的时候初始化

```go
test := Test{1, 2}  // 定义结构体变量并初始化
```

初始化部分结构体字段

```go
t2  = Test{a: 3}   //指定赋值Test.a为3  Test.b隐式赋值0
```

隐式初始化

```go
t3  = Test{}       // .a .b都隐式赋值0
```

多个变量可以分组一起赋值

```go
var (
    t1  = Test{8, 6}
    t2  = Test{a: 3}  //指定赋值Test.a  Test.b隐式赋值0
    t3  = Test{}      // .a .b都隐式赋值0
)
```



### 访问成员

通过 `.` 运算来访问结构体成员，「不区分结构体类型或是结构体指针类型」都可以用 `.` 号来访问。

```go
fmt.Println("struct", st0.a, st0.b) // 通过 . 运算来访问结构体成员
```



对于只声明没赋值的结构体，其内部变量被赋予零值。下面我们声明了 `st0` 但没有对其赋值，成员 a 和 b 自动赋零值。

```go
var st0 Test 	
fmt.Println("struct", st0.a, st0.b) //输出：struct 0 0
```



## 指针

指针不保存实际数据的内容，而是保存了指向值的内存地址 。用 `&` 对变量取内存地址，用 `*` 来访问指向的内存，这点和 C 中的指针是一样，唯一不同的是 Go 中的指针不能运算。

```go
	a := 3
	pa := &a // 用 `&` 对变量取内存地址
	fmt.Println("point", a, *pa) // 用 `*` 来访问指向的内存
```

只声明没赋值的指针值是 `nil` ，代表空指针。 

```go
	var a0 *int // 只声明没赋值的指针是nil
	if a0 == nil {
		fmt.Println("point", "it is nil point")
	}
```



## 数组

 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 数组可以用下标访问元素，下标从 0 开始。

数组声明后赋值

```go
	var strarr [2]string // 数组声明语法
	strarr[0] = "ready"
	strarr[1] = "go"
```

声明赋值同时完成

```go
	intarr := [5]int{6, 8, 9, 10, 7} // 声明赋值同时完成
```

对于确定初始值个数的数组，可以省略数组长度用 `...` 代替。

```go
	intarr := [...]int{6, 8, 9, 10, 7} // 声明赋值同时完成
```



## Slice 切片

切片是变长的序列，序列中每个元素都有相同的类型。`slice` 语法和数组很像，只是没有固定长度而已，「切片底层引用一个数组对象」修改切片会修改原数组。

通过切片可以访问数组的部分或全部元素，正因为切片长度不是固定的，因此切片比数组更加的常用。



### 声明与初始化

#### 常规初始化

简短声明并初始化切片

```go
s0 := []int{1, 2, 3, 4, 5, 6} // 简短声明加赋值
```

声明后再初始化

```go
var s []int        // 声明切片s
s = s0			  // 用切片s0初始化切片s
```

声明并初始化切片

```go
var s00 []int = s0 // 用切片s0初始化切片s
```

切片的零值是 `nil`

```go
// 切片的零值是nil 空切片长度和容量都是0
var nilslice []int
if nilslice == nil {
    fmt.Println("slice", "nilslice is nil ", len(nilslice), cap(nilslice))
}

```

#### make初始化

除了上述的常规初始化方法，还可以用 `make` 内置函数来创建切片

```go
// 内建函数make创建切片，指定切片长度和容量
// make 函数会分配一个元素为零值的数组并返回一个引用了它的切片
s2 := make([]int, 4, 6) //创建元素都是0的切片s2, 长度为4，容量为6 第三个参数可以省略
fmt.Println("slice", len(s2), cap(s2), s2)
```



#### 切片长度和容量

 切片长度表示切片中元素的数目，可用内置函数 `len` 函数得到。

 容量表示切片中第一个元素到引用的底层数组结尾所包含元素个数，可用内置函数 `cap` 求得。

```go
s0 := []int{1, 2, 3, 4, 5, 6} // 简短声明加赋值
len1, cap1 := len(s0), cap(s0)
len2, cap2 := len(s0[:4]), cap(s0[:4])
len3, cap3 := len(s0[2:]), cap(s0[2:])
fmt.Println("slice", len1, cap1, len2, cap2, len3, cap3) // 6 6 4 6 4 4
```



#### 切片区间

切片区间遵循「左闭右开」原则，

```go 
s0 := [5]int{6, 8, 9, 10, 7} // 数组定义
var slice []int = intarr[1:4]    //  创建切片slice 包含数组子序列
```

 默认上下界。切片下界的默认值为 0，上界默认是该切片的长度。

```go
fmt.Println("slice", s0[:], s0[0:], s0[:5], s0[0:5]) // 这四个切片相同
```



### 切片append操作

append 函数用于在切片末尾追加新元素。

添加元素也分两种情况。

#### 添加之后长度还在原切片容量范围内

```go
s2 := make([]int, 4, 6) // 创建元素都是0的切片s2, 长度为4，容量为6 第三个参数可以省略
s21 := append(s2, 1)
s22 := append(s2, 2)    // append每次都是在最后添加，此时，s21 s22指向同一个底层数组；但s2不改变！
fmt.Println(s2, s21, s22)   //  [0 0 0 0] [0 0 0 0 2] [0 0 0 0 2]
```


#### 添加元素之后长度超出原切片容量

此时会分配新的数组空间，并返回指向这个新分配的数组的切片。

下面例子中 s24 切片已经指向新分配的数组，s22 依然指向的是原来的数组空间，而 s24 已经指向了新的底层数组。

```go
	s24 := append(s2, 1, 2, 3)
	fmt.Println(s24, s22) // s24 [0 0 0 0 1 2 3] [0 0 0 0 2]
```

### 二维切片

可以定义切片的切片，类似其他语言中的二维数组用法。参考代码：

```go
	s3 := [][]int{
		{1, 1, 1},
		{2, 2, 2},
	}
	fmt.Println(s3, s3[0], len(s3), cap(s3)) // 输出： [[1 1 1] [2 2 2]] [1 1 1] 2 2
```



## map 映射类型

在 Go 中 `map` 是键值对类型，代表 `key` 和` value` 的映射关系，一个 map 就是一个哈希表的引用 。

### 定义和初始化

下面这样定义并初始化一个 map 变量

```go
	m0 := map[int]string{
		0: "0",
		1: "1",
	}
```

也可以用内置 make 函数来初始化一个 map 变量，后续再向其中添加键值对。像下面这样：

```go
	m1 := make(map[int]string) // make 函数会返回给定类型的映射，并将其初始化备用
	if m1 != nil {
		fmt.Println("map", "m1 is not nil", m1) // m1 不是nil
	}
	m1[0] = "1"
	m1[1] = "2"
```

注意：只声明不初始化的map变量是 `nil` 映射，不能直接拿来用！

```go
	var m map[int]string // 未初始化的m零值是nil映射
	if m == nil {
		fmt.Println("map", "m is nil", m)
	}
	//m[0] = "1" // 这句引发panic异常， 映射的零值为 nil 。nil映射既没有键，也不能添加键。
```

### 元素读取

使用语法：`vaule= m[key]` 获取键 key 对应的元素 vaule 。

上面我们只用了一个变量来获取元素，其实这个操作会返回两个值，第一个返回值代表读书的元素，第二个返回值是代表键是否存在的 bool 类型，举例说明：

```go
	v, st := m1[0]  // v是元素值，下标对应的元素存在st=true 否则st=false
	_, st1 := m1[0] // _ 符号表示忽略第一个元素
	v1, _ := m1[0]  // _ 符号表示忽略第二个元素	
	fmt.Println(v, st, v1, st1, m1[2]) // m1[2]不存在，返回元素string的零值「空字符」
```

### 删除元素

内置函数 `delete` 可以删除 map 元素，举例：

```
delete(m1, 1)  // 删除键是 1 的元素
```



## range 遍历

range 用于遍历 切片 或 映射。

### 数组或切片遍历

当使用` for` 循环和 `range` 遍历数组或切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

```go
s1 := []int{1, 2, 3, 4, 5, 6} 	
for key, vaule := range s1 {
    fmt.Println("range", key, vaule)
}

for key := range s1 { // 只需要索引，忽略第二个变量即可
    fmt.Println("range", key)
}

for _, vaule := range s1 { // 只需要元素值，用'_'忽略索引
    fmt.Println("range", vaule)
}
```



### map 遍历

当使用` for` 循环和 `range` 遍历` map` 时，每次迭代都会返回两个值。第一个值为当前元素 `key` ， 第二个值是 `value`。

```go
m0 := map[int]string{
    0: "0",
    1: "1",
}
fmt.Println("map", m0)

for k, v := range m0 { // range遍历映射，返回key 和 vaule
    fmt.Println("map", "m0 key:", k, "vaule:", v)
}
```



## 总结

通过本文的学习，我们掌握了 Golang 中复合类型的学习，这些复合类型代表的数据结构都比较常见，比如切片和数组可以用于模仿队列或堆栈，`map` 的底层实现是 `hash` 表，当然初学者可以不必在意这些底层实现，先用起来已经领先大部分观望者。

感谢各位的阅读，文章的目的是分享对知识的理解，技术类文章我都会反复求证以求最大程度保证准确性，若文中出现明显纰漏也欢迎指出，我们一起在探讨中学习.

今天的技术分享就到这里，我们下期再见。

-----



**创作不易，白票不是好习惯，如果有收获，动动手指点个「在看」或给个「转发」是对我持续创作的最大支持**

## 

